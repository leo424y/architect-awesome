
<h1>《後端架構師技術圖譜》</h1>

**最後更新於20180427**

* [資料結構](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料結構)
	* [佇列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#佇列)
	* [集合](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合)
	* [連結串列、陣列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#連結串列陣列)
	* [字典、關聯陣列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典關聯陣列)
	* [棧](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#棧)
	* [樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#樹)
		* [二叉樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉樹)
		* [完全二叉樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉樹)
		* [平衡二叉樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉樹)
		* [二叉查詢樹（BST）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查詢樹bst)
		* [紅黑樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#紅黑樹)
		* [B-，B+，B*樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb樹)
		* [LSM 樹](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-樹)
	* [BitSet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset)
* [常用演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用演算法)
	* [排序、查詢演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查詢演算法)
		* [選擇排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#選擇排序)
		* [氣泡排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#氣泡排序)
		* [插入排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序)
		* [快速排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序)
		* [歸併排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#歸併排序)
		* [希爾排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希爾排序)
		* [堆排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序)
		* [計數排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#計數排序)
		* [桶排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序)
		* [基數排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基數排序)
		* [二分查詢](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查詢)
		* [Java 中的排序工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具)
	* [布隆過濾器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆過濾器)
	* [字串比較](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字串比較)
		* [KPM 演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kpm-演算法)
	* [深度優先、廣度優先](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度優先廣度優先)
	* [貪心演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#貪心演算法)
	* [回溯演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯演算法)
	* [剪枝演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝演算法)
	* [動態規劃](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#動態規劃)
	* [樸素貝葉斯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#樸素貝葉斯)
	* [推薦演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推薦演算法)
	* [最小生成樹演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成樹演算法)
	* [最短路徑演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路徑演算法)
* [併發](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#併發)
	* [多執行緒](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多執行緒)
	* [執行緒安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#執行緒安全)
	* [一致性、事務](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事務)
		* [事務 ACID 特性](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事務-acid-特性)
		* [事務的隔離級別](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事務的隔離級別)
	* [鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#鎖)
		* [Java中的鎖和同步類](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的鎖和同步類)
		* [公平鎖 &amp; 非公平鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平鎖--非公平鎖)
		* [悲觀鎖 &amp; 樂觀鎖 &amp; CAS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲觀鎖--樂觀鎖--cas)
		* [ABA 問題](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-問題)
		* [CopyOnWrite容器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器)
		* [RingBuffer](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer)
		* [可重入鎖 &amp; 不可重入鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入鎖--不可重入鎖)
		* [互斥鎖 &amp; 共享鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥鎖--共享鎖)
		* [死鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死鎖)
* [作業系統](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#作業系統)
	* [計算機原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#計算機原理)
	* [程序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#程序)
	* [執行緒](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#執行緒)
	* [協程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#協程)
	* [Linux](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux)
* [設計模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#設計模式)
	* [設計模式的六大原則](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#設計模式的六大原則)
	* [23種常見設計模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23種常見設計模式)
	* [應用場景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#應用場景)
	* [單例模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#單例模式)
	* [責任鏈模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#責任鏈模式)
	* [MVC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc)
	* [IOC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc)
	* [AOP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop)
	* [UML](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml)
	* [微服務思想](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服務思想)
		* [康威定律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律)
* [運維 &amp; 統計 &amp; 技術支援](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#運維--統計--技術支援)
	* [常規監控](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常規監控)
	* [APM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm)
	* [統計分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#統計分析)
	* [持續整合(CI/CD)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持續整合cicd)
		* [Jenkins](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins)
		* [環境分離](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#環境分離)
	* [自動化運維](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自動化運維)
		* [Ansible](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible)
		* [puppet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet)
		* [chef](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef)
	* [測試](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#測試)
		* [TDD 理論](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理論)
		* [單元測試](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#單元測試)
		* [壓力測試](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#壓力測試)
		* [全鏈路壓測](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全鏈路壓測)
		* [A/B Test](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-test)
	* [虛擬化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虛擬化)
		* [KVM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm)
		* [Xen](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen)
		* [OpenVZ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz)
	* [容器技術](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技術)
		* [Docker](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker)
	* [雲技術](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#雲技術)
		* [OpenStack](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack)
	* [DevOps](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops)
	* [文件管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件管理)
* [中介軟體](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中介軟體)
	* [Web Server](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server)
		* [Nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)
		* [OpenResty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty)
		* [Apache Httpd](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd)
		* [Tomcat](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat)
			* [架構原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架構原理)
			* [調優方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#調優方案)
		* [Jetty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty)
	* [快取](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快取)
		* [本地快取](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地快取)
	* [客戶端快取](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客戶端快取)
		* [Memcached](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached)
		* [Redis](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis)
			* [架構](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架構)
			* [回收策略](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略)
		* [Tair](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair)
	* [訊息佇列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#訊息佇列)
		* [訊息匯流排](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#訊息匯流排)
		* [訊息的順序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#訊息的順序)
		* [RabbitMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq)
		* [RocketMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq)
		* [ActiveMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq)
		* [Kafka](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka)
		* [Redis 訊息推送](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-訊息推送)
		* [ZeroMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq)
	* [定時排程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定時排程)
		* [單機定時排程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#單機定時排程)
		* [分散式定時排程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式定時排程)
	* [RPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc)
		* [Dubbo](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo)
		* [Thrift](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift)
		* [gRPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc)
	* [資料庫中介軟體](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料庫中介軟體)
		* [Sharding Jdbc](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc)
	* [日誌系統](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日誌系統)
		* [日誌蒐集](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日誌蒐集)
	* [配置中心](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心)
	* [API 閘道器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-閘道器)
* [網路](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#網路)
	* [協議](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#協議)
		* [OSI 七層協議](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七層協議)
		* [TCP/IP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip)
		* [HTTP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http)
		* [HTTP2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20)
		* [HTTPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https)
	* [網路模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#網路模型)
		* [Epoll](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll)
		* [NIO](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nio)
		* [kqueue](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue)
	* [連線和短連線](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#連線和短連線)
	* [框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架)
	* [零拷貝（Zero-copy）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷貝zero-copy)
	* [序列化(二進位制協議)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二進位制協議)
		* [Hessian](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian)
		* [Protobuf](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf)
* [資料庫](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料庫)
	* [基礎理論](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基礎理論)
		* [資料庫設計的三大正規化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料庫設計的三大正規化)
	* [MySQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql)
		* [原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理)
		* [InnoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb)
		* [優化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#優化)
		* [索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引)
			* [聚集索引, 非聚集索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引)
			* [複合索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#複合索引)
			* [自適應雜湊索引(AHI)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自適應雜湊索引ahi)
		* [explain](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain)
	* [NoSQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql)
		* [MongoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb)
		* [Hbase](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase)
* [搜尋引擎](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜尋引擎)
	* [搜尋引擎原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜尋引擎原理)
	* [Lucene](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene)
	* [Elasticsearch](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch)
	* [Solr](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr)
	* [sphinx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx)
* [效能](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#效能)
	* [效能優化方法論](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#效能優化方法論)
	* [容量評估](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量評估)
	* [CDN 網路](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-網路)
	* [連線池](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#連線池)
	* [效能調優](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#效能調優)
	* [流式計算](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式計算)
		* [Storm](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm)
		* [Flink](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink)
		* [Kafka Stream](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream)
		* [應用場景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#應用場景-1)
	* [Hadoop](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop)
		* [HDFS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs)
		* [MapReduce](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce)
		* [Yarn](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn)
	* [Spark](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark)
* [安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全)
	* [web 安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全)
		* [XSS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss)
		* [CSRF](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf)
		* [SQL 注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入)
		* [Hash Dos](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos)
		* [指令碼注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#指令碼注入)
		* [漏洞掃描工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞掃描工具)
		* [驗證碼](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#驗證碼)
	* [DDoS 防範](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防範)
	* [使用者隱私資訊保護](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#使用者隱私資訊保護)
	* [加密解密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密)
		* [對稱加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#對稱加密)
		* [雜湊演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#雜湊演算法)
		* [非對稱加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非對稱加密)
	* [伺服器安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#伺服器安全)
	* [資料安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料安全)
		* [資料備份](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料備份)
	* [網路隔離](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#網路隔離)
		* [內外網分離](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#內外網分離)
		* [登入跳板機](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登入跳板機)
	* [授權](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授權)
		* [RBAC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac)
		* [OAuth2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20)
* [常用開源框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用開源框架)
	* [開源協議](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#開源協議)
	* [日誌框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日誌框架)
		* [Log4j、Log4j2](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2)
		* [Logback](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback)
	* [ORM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm)
	* [網路框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#網路框架)
	* [Web 框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架)
		* [Spring 家族](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族)
	* [工具框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架)
* [分散式設計](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式設計)
	* [擴充套件性設計](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#擴充套件性設計)
	* [穩定性 &amp; 高可用](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#穩定性--高可用)
		* [硬體負載均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬體負載均衡)
		* [軟體負載均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#軟體負載均衡)
		* [限流](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流)
		* [應用層容災](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#應用層容災)
		* [跨機房容災](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨機房容災)
		* [容災演練流程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容災演練流程)
		* [平滑啟動](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑啟動)
	* [資料庫擴充套件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資料庫擴充套件)
		* [讀寫分離模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#讀寫分離模式)
		* [分片模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式)
	* [服務治理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服務治理)
		* [服務註冊與發現](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服務註冊與發現)
		* [服務路由控制](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服務路由控制)
	* [分散式一致](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式一致)
		* [CAP 與 BASE 理論](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-與-base-理論)
		* [分散式鎖](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式鎖)
		* [分散式一致性演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式一致性演算法)
			* [PAXOS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos)
			* [Zab](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab)
			* [Raft](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft)
			* [Gossip](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip)
			* [兩階段提交、多階段提交](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#兩階段提交多階段提交)
		* [冪等](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冪等)
		* [分散式一致方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式一致方案)
		* [分散式 Leader 節點選舉](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式-leader-節點選舉)
		* [TCC(Try/Confirm/Cancel) 柔性事務](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事務)
	* [分散式檔案系統](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分散式檔案系統)
	* [唯一ID 生成](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成)
		* [全域性唯一ID](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全域性唯一id)
	* [一致性Hash演算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash演算法)
* [設計思想 &amp; 開發模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#設計思想--開發模式)
	* [DDD(Domain-driven Design - 領域驅動設計)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---領域驅動設計)
		* [命令查詢職責分離(CQRS)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查詢職責分離cqrs)
		* [貧血，充血模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#貧血充血模型)
	* [Actor 模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式)
	* [響應式程式設計](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#響應式程式設計)
	* [DODAF2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20)
	* [Serverless](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless)
* [專案管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#專案管理)
	* [架構評審](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架構評審)
	* [重構](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重構)
	* [程式碼規範](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#程式碼規範)
	* [RUP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup)
	* [看板管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理)
	* [SCRUM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum)
	* [極限程式設計](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#極限程式設計)
	* [敏捷開發](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷開發)
	* [結對程式設計](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#結對程式設計)
* [通用業務術語](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用業務術語)
* [技術趨勢](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技術趨勢)
* [架構師素質](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架構師素質)
* [團隊管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#團隊管理)
	* [招聘](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘)
* [資訊](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#資訊)
	* [行業資訊](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行業資訊)
	* [公眾號列表](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公眾號列表)
	* [部落格](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#部落格)
		* [團隊部落格](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#團隊部落格)
		* [個人部落格](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#個人部落格)
	* [綜合門戶、社羣](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#綜合門戶社羣)
	* [問答、討論類社羣](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#問答討論類社羣)
	* [行業資料分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行業資料分析)
	* [專項網站](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#專項網站)
	* [其他類](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他類)
	* [推薦參考書](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推薦參考書)
		* [線上電子書](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#線上電子書)
		* [紙質書](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#紙質書)
			* [開發方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#開發方面)
			* [架構方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架構方面)
			* [技術管理方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技術管理方面)
			* [基礎理論](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基礎理論-1)
			* [工具方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面)
			* [大資料方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大資料方面)
* [技術資源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技術資源)
	* [開源資源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#開源資源)
	* [手冊、文件、教程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手冊文件教程)
	* [線上課堂](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#線上課堂)
	* [會議、活動](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#會議活動)
	* [常用APP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app)
	* [找工作](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作)
	* [工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具)
	* [程式碼託管](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#程式碼託管)
	* [檔案服務](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#檔案服務)
	* [綜合雲服務商](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#綜合雲服務商)

**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**

# 資料結構

## 佇列
* [《java佇列——queue詳細分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)
	* 非阻塞佇列：ConcurrentLinkedQueue(無界執行緒安全)，採用CAS機制（compareAndSwapObject原子操作）。
	* 阻塞佇列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（無界）、DelayQueue、PriorityBlockingQueue，採用鎖機制；使用 ReentrantLock 鎖。

* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue對比分析》](https://www.cnblogs.com/mantu/p/5802393.html)

## 集合
* [《Java Set集合的詳解》](https://blog.csdn.net/qq_33642117/article/details/52040345)

## 連結串列、陣列
* [《Java集合詳解--什麼是List》](https://blog.csdn.net/wz249863091/article/details/52853360)

## 字典、關聯陣列
* [《Java map 詳解 - 用法、遍歷、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)

## 棧
* [《java資料結構與演算法之棧（Stack）設計與實現》](https://blog.csdn.net/javazejian/article/details/53362993)
* [《Java Stack 類》](http://www.runoob.com/java/java-stack-class.html)
* [《java stack的詳細實現分析》](https://blog.csdn.net/f2006116/article/details/51375225)
	* Stack 是執行緒安全的。
	* 內部使用陣列儲存資料，不夠時翻倍。

## 樹

### 二叉樹

每個節點最多有兩個葉子節點。
*  [《二叉樹》](https://blog.csdn.net/cai2016/article/details/52589952)

### 完全二叉樹
* [《完全二叉樹》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)
	* 葉節點只能出現在最下層和次下層，並且最下面一層的結點都集中在該層最左邊的若干位置的二叉樹。

### 平衡二叉樹
左右兩個子樹的高度差的絕對值不超過1，並且左右兩個子樹都是一棵平衡二叉樹。
* [《淺談資料結構-平衡二叉樹》](http://www.cnblogs.com/polly333/p/4798944.html)
* [《淺談演算法和資料結構: 八 平衡查詢樹之2-3樹》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)

### 二叉查詢樹（BST）
二叉查詢樹（Binary Search Tree），也稱有序二叉樹（ordered binary tree）,排序二叉樹（sorted binary tree）。

* [《淺談演算法和資料結構: 七 二叉查詢樹》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)


### 紅黑樹
* [《最容易懂得紅黑樹》](https://blog.csdn.net/sun_tttt/article/details/65445754)
	* 新增階段後，左旋或者右旋從而再次達到平衡。
* [《淺談演算法和資料結構: 九 平衡查詢樹之紅黑樹》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)

### B-，B+，B*樹
MySQL是基於B+樹聚集索引組織表

* [《B-樹，B+樹，B\*樹詳解》](https://blog.csdn.net/aqzwss/article/details/53074186)
* [《B-樹，B+樹與B\*樹的優缺點比較》](https://blog.csdn.net/bigtree_3721/article/details/73632405)
	* B+ 數的葉子節點連結串列結構相比於 B- 數便於掃庫，和範圍檢索。
### LSM 樹

LSM（Log-Structured Merge-Trees）和 B+ 樹相比，是犧牲了部分讀的效能來換取寫的效能(通過批量寫入)，實現讀寫之間的。
Hbase、LevelDB、Tair（Long DB）、nessDB 採用 LSM 樹的結構。LSM可以快速建立索引。

* [《LSM樹 VS B+樹》](https://blog.csdn.net/dbanote/article/details/8897599)
	* B+ 樹讀效能好，但由於需要有序結構，當key比較分散時，磁碟尋道頻繁，造成寫效能。
	* LSM 是將一個大樹拆分成N棵小樹，先寫到記憶體（無尋道問題，效能高），在記憶體中構建一顆有序小樹（有序樹），隨著小樹越來越大，記憶體的小樹會flush到磁碟上。當讀時，由於不知道資料在哪棵小樹上，因此必須遍歷（二分查詢）所有的小樹，但在每顆小樹內部資料是有序的。

* [《LSM樹（Log-Structured Merge Tree）儲存引擎》](https://blog.csdn.net/u014774781/article/details/52105708)
	* 極端的說，基於LSM樹實現的HBase的寫效能比MySQL高了一個數量級，讀效能低了一個數量級。
	* 優化方式：Bloom filter 替代二分查詢；compact 小數位大樹，提高查詢效能。
	* Hbase 中，記憶體中達到一定閾值後，整體flush到磁碟上、形成一個檔案（B+數），HDFS不支援update操作，所以Hbase做整體flush而不是merge update。flush到磁碟上的小樹，定期會合併成一個大樹。

## BitSet

經常用於大規模資料的排重檢查。

* [《Java Bitset類》](http://www.runoob.com/java/java-bitset-class.html)
* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)

# 常用演算法

* [《常見排序演算法及對應的時間複雜度和空間複雜度》](https://blog.csdn.net/gane_cheng/article/details/52652705)

## 排序、查詢演算法

* [《常見排序演算法及對應的時間複雜度和空間複雜度》](https://blog.csdn.net/gane_cheng/article/details/52652705)

### 選擇排序
* [《Java中的經典演算法之選擇排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)
	* 每一趟從待排序的記錄中選出最小的元素，順序放在已排好序的序列最後，直到全部記錄排序完畢。

### 氣泡排序
* [《氣泡排序的2種寫法》](https://blog.csdn.net/shuaizai88/article/details/73250615)
	* 相鄰元素前後交換、把最大的排到最後。
	* 時間複雜度 O(n²)

### 插入排序
* [《排序演算法總結之插入排序》](https://blog.csdn.net/shuaizai88/article/details/73250615)

### 快速排序
* [《坐在馬桶上看演算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)
	* 一側比另外一次都大或小。
### 歸併排序
* [《圖解排序演算法(四)之歸併排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)
	* 分而治之，分成小份排序，在合併(重建一個新空間進行復制)。

### 希爾排序
TODO

### 堆排序
* [《圖解排序演算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)
	* 排序過程就是構建最大堆的過程，最大堆：每個結點的值都大於或等於其左右孩子結點的值，堆頂元素是最大值。

### 計數排序
* [《計數排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)
	* 和桶排序過程比較像，差別在於桶的數量。

### 桶排序
* [《【啊哈！演算法】最快最簡單的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)
* [《排序演算法（三）：計數排序與桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)
	* 桶排序將[0,1)區間劃分為n個相同的大小的子區間，這些子區間被稱為桶。
	* 每個通單獨進行排序，然後再遍歷每個桶。

### 基數排序

按照個位、十位、百位、...依次來排。

* [《排序演算法系列：基數排序》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)
* [《基數排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)


### 二分查詢
* [《二分查詢(java實現)》](https://www.cnblogs.com/coderising/p/5708632.html)
	* 要求待查詢的序列有序。
	* 時間複雜度 O(logN)。

* [《java實現二分查詢-兩種方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)
	* while + 遞迴。
### Java 中的排序工具
* [《Arrays.sort和Collections.sort實現原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)
	* Collections.sort演算法呼叫的是合併排序。
	* Arrays.sort() 採用了2種排序演算法 -- 基本型別資料使用快速排序法，物件陣列使用歸併排序。

## 布隆過濾器

常用於大資料的排重，比如email，url 等。
核心原理：將每條資料通過計算產生一個指紋（一個位元組或多個位元組，但一定比原始資料要少很多），其中每一位都是通過隨機計算獲得，在將指紋對映到一個大的按位儲存的空間中。注意：會有一定的錯誤率。
優點：空間和時間效率都很高。
缺點：隨著存入的元素數量增加，誤算率隨之增加。

* [《布隆過濾器 -- 空間效率很高的資料結構》](https://segmentfault.com/a/1190000002729689)
* [《大量資料去重：Bitmap和布隆過濾器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)
* [《基於Redis的布隆過濾器的實現》](https://blog.csdn.net/qq_30242609/article/details/71024458)
	* 基於 Redis 的 Bitmap 資料結構。
* [《網路爬蟲：URL去重策略之布隆過濾器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)
	* 使用Java中的 BitSet 類 和 加權和hash演算法。

## 字串比較

### KPM 演算法
KPM：Knuth-Morris-Pratt演算法（簡稱KMP）
核心原理是利用一個“部分匹配表”，跳過已經匹配過的元素。
* [《字串匹配的KMP演算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

## 深度優先、廣度優先
* [《廣度優先搜尋BFS和深度優先搜尋DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)

## 貪心演算法
* [《演算法：貪婪演算法基礎》](https://www.cnblogs.com/MrSaver/p/8641971.html)
* [《常見演算法及問題場景——貪心演算法》](https://blog.csdn.net/a345017062/article/details/52443781)

## 回溯演算法
* [《 五大常用演算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)

## 剪枝演算法
* [《α-β剪枝演算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)

## 動態規劃
* [《詳解動態規劃——鄒博講動態規劃》](https://www.cnblogs.com/little-YTMM/p/5372680.html)
* [《動態規劃演算法的個人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)

## 樸素貝葉斯

* [《帶你搞懂樸素貝葉斯分類演算法》](https://blog.csdn.net/amds123/article/details/70173402)
	* P(B|A)=P(A|B)P(B)/P(A)

* [《貝葉斯推斷及其網際網路應用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)
* [《貝葉斯推斷及其網際網路應用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)


## 推薦演算法
* [《推薦演算法綜述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)
* [《TOP 10 開源的推薦系統簡介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)

## 最小生成樹演算法
* [《演算法導論--最小生成樹（Kruskal和Prim演算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)

## 最短路徑演算法

* [《Dijkstra演算法詳解》](https://blog.csdn.net/qq_35644234/article/details/60870719)

# 併發

## 多執行緒

* [《40個Java多執行緒問題總結》](http://www.importnew.com/18459.html)

## 執行緒安全

* [《Java併發程式設計——執行緒安全及解決機制簡介》](https://www.cnblogs.com/zhanht/p/5450325.html)

## 一致性、事務

### 事務 ACID 特性
* [《資料庫事務ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)

### 事務的隔離級別

* 未提交讀：一個事務可以讀取另一個未提交的資料，容易出現髒讀的情況。
* 讀提交：一個事務等另外一個事務提交之後才可以讀取資料，但會出現不可重複讀的情況（多次讀取的資料不一致），讀取過程中出現UPDATE操作，會多。（大多數資料庫預設級別是RC，比如SQL Server，Oracle），讀取的時候不可以修改。
* 可重複讀： 同一個事務裡確保每次讀取的時候，獲得的是同樣的資料，但不保障原始資料被其他事務更新（幻讀），Mysql InnoDB 就是這個級別。
* 序列化：所有事物序列處理（犧牲了效率）

* [《理解事務的4種隔離級別》](https://blog.csdn.net/qq_33290787/article/details/51924963)
* [資料庫事務的四大特性及事務隔離級別](https://www.cnblogs.com/z-sm/p/7245981.html)

* [《MySQL的InnoDB的幻讀問題 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)
	* 幻讀的例子非常清楚。
	* 通過 SELECT ... FOR UPDATE 解決。

* [《一篇文章帶你讀懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)
	* 圖解髒讀、不可重複讀、幻讀問題。


### MVCC


* [《【mysql】關於innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)
	* innodb 中 MVCC 用在 Repeatable-Read 隔離級別。
	* MVCC 會產生幻讀問題（更新時異常。）

* [《輕鬆理解MYSQL MVCC 實現機制》](https://blog.csdn.net/whoamiyang/article/details/51901888)

	* 通過隱藏版本列來實現 MVCC 控制，一列記錄建立時間、一列記錄刪除時間，這裡的時間
	* 每次只操作比當前版本小（或等於）的 行。



## 鎖

### Java中的鎖和同步類

* [《Java中的鎖分類》](https://www.cnblogs.com/qifengshi/p/6831055.html)
	* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。

* [《Java併發之AQS詳解》](https://www.cnblogs.com/waterystone/p/4920797.html)

* [《Java中訊號量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)
	* 有數量控制
	* 申請用 acquire，申請不要則阻塞；釋放用 release。

* [《java開發中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)
	* 簡單的說 就是Mutex是排它的，只有一個可以獲取到資源， Semaphore也具有排它性，但可以定義多個可以獲取的資源的物件。	 

### 公平鎖 & 非公平鎖

公平鎖的作用就是嚴格按照執行緒啟動的順序來執行的，不允許其他執行緒插隊執行的；而非公平鎖是允許插隊的。

* [《公平鎖與非公平鎖》](https://blog.csdn.net/EthanWhite/article/details/55508357)
	* 預設情況下 ReentrantLock 和 synchronized 都是非公平鎖。ReentrantLock 可以設定成公平鎖。

### 悲觀鎖

悲觀鎖如果使用不當（鎖的條數過多），會引起服務大面積等待。推薦優先使用樂觀鎖+重試。

* [《【MySQL】悲觀鎖&樂觀鎖》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)
	* 樂觀鎖的方式：版本號+重試方式
	* 悲觀鎖：通過 select ... for update 進行行鎖(不可讀、不可寫，share 鎖可讀不可寫)。

* [《Mysql查詢語句使用select.. for update導致的資料庫死鎖分析》](https://www.cnblogs.com/Lawson/p/5008741.html)
	* mysql的innodb儲存引擎實務鎖雖然是鎖行，但它內部是鎖索引的。
	* 鎖相同資料的不同索引條件可能會引起死鎖。

* [《Mysql併發時經典常見的死鎖原因及解決方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)

### 樂觀鎖 & CAS

* [《樂觀鎖的一種實現方式——CAS》](http://www.importnew.com/20472.html)
	* 和MySQL樂觀鎖方式相似，只不過是通過和原值進行比較。	 

### ABA 問題

由於高併發，在CAS下，更新後可能此A非彼A。通過版本號可以解決，類似於上文Mysql 中提到的的樂觀鎖。

* [《Java CAS 和ABA問題》](https://www.cnblogs.com/549294286/p/3766717.html)
* [《Java 中 ABA問題及避免》](https://blog.csdn.net/li954644351/article/details/50511879)
	* AtomicStampedReference 和 AtomicStampedReference。

### CopyOnWrite容器

可以對CopyOnWrite容器進行併發的讀，而不需要加鎖。CopyOnWrite併發容器用於讀多寫少的併發場景。比如白名單，黑名單，商品類目的訪問和更新場景，不適合需要資料強一致性的場景。

* [《JAVA中寫時複製(Copy-On-Write)Map實現》](https://www.cnblogs.com/hapjin/p/4840107.html)
	* 實現讀寫分離，讀取發生在原始資料上，寫入發生在副本上。  
	* 不用加鎖，通過最終一致實現一致性。

* [《聊聊併發-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)

### RingBuffer
* [《執行緒安全的無鎖RingBuffer的實現【一個讀執行緒，一個寫執行緒】》](http://www.cnblogs.com/l00l/p/4115001.html)

### 可重入鎖 & 不可重入鎖

* [《可重入鎖和不可重入鎖》](https://www.cnblogs.com/dj3839/p/6580765.html)
	* 通過簡單程式碼舉例說明可重入鎖和不可重入鎖。
	* 可重入鎖指同一個執行緒可以再次獲得之前已經獲得的鎖。
	* 可重入鎖可以使用者避免死鎖。
	* Java中的可重入鎖：synchronized 和 java.util.concurrent.locks.ReentrantLock

* [《ReenTrantLock可重入鎖（和synchronized的區別）總結》](https://www.cnblogs.com/baizhanshi/p/7211802.html)
	* synchronized 使用方便，編譯器來加鎖，是非公平鎖。
	* ReenTrantLock 使用靈活，鎖的公平性可以定製。
	* 相同加鎖場景下，推薦使用 synchronized。

### 互斥鎖 & 共享鎖

互斥鎖：同時只能有一個執行緒獲得鎖。比如，ReentrantLock 是互斥鎖，ReadWriteLock 中的寫鎖是互斥鎖。
共享鎖：可以有多個執行緒同時或的鎖。比如，Semaphore、CountDownLatch 是共享鎖，ReadWriteLock 中的讀鎖是共享鎖。

* [《ReadWriteLock場景應用》](https://www.cnblogs.com/liang1101/p/6475555.html)

### 死鎖
* [《“死鎖”四個必要條件的合理解釋》](https://blog.csdn.net/yunfenglw/article/details/45950305)
	* 互斥、持有、不可剝奪、不可剝奪。
* [Java如何檢視死鎖？](https://blog.csdn.net/u014039577/article/details/52351626)
	* JConsole 可以識別死鎖。

* [java多執行緒系列：死鎖及檢測](https://blog.csdn.net/bohu83/article/details/51135061)
	* jstack 可以顯示死鎖。

# 作業系統

## 計算機原理

* [《作業系統基礎知識——作業系統的原理，型別和結構》](https://segmentfault.com/a/1190000003692840)

## 程序

TODO

## 執行緒

* [《執行緒的生命週期及狀態轉換詳解》](https://blog.csdn.net/asdf_1024/article/details/78978437)

## 協程

* [《終結python協程----從yield到actor模型的實現》](https://www.thinksaas.cn/group/topic/839375/)
	* 執行緒的排程是由作業系統負責，協程排程是程式自行負責
	* 與執行緒相比，協程減少了無畏的作業系統切換.
	* 實際上當遇到IO操作時做切換才更有意義，（因為IO操作不用佔用CPU），如果沒遇到IO操作，按照時間片切換.

## Linux

* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)

# 設計模式

## 設計模式的六大原則
* [《設計模式的六大原則》](https://blog.csdn.net/q291611265/article/details/48465113)
	* 開閉原則：對擴充套件開放,對修改關閉，多使用抽象類和介面。
	* 里氏代換原則：基類可以被子類替換，使用抽象類繼承,不使用具體類繼承。
	* 依賴倒轉原則：要依賴於抽象,不要依賴於具體，針對介面程式設計,不針對實現程式設計。
	* 介面隔離原則：使用多個隔離的介面,比使用單個介面好，建立最小的介面。
	* 迪米特法則：一個軟體實體應當儘可能少地與其他實體發生相互作用，通過中間類建立聯絡。
	* 合成複用原則：儘量使用合成/聚合,而不是使用繼承，儘量使用合成/聚合,而不是使用繼承。

## 23種常見設計模式
* [《設計模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
* [《23種設計模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)

## 應用場景
* [《細數JDK裡的設計模式》](http://blog.jobbole.com/62314/)
	* 結構型模式：
		* 介面卡：用來把一個介面轉化成另一個介面，如 java.util.Arrays#asList()。
		* 橋接模式：這個模式將抽象和抽象操作的實現進行了解耦，這樣使得抽象和實現可以獨立地變化，如JDBC；
		* 組合模式：使得客戶端看來單個物件和物件的組合是同等的。換句話說，某個型別的方法同時也接受自身型別作為引數，如 Map.putAll，List.addAll、Set.addAll。
		* 裝飾者模式：動態的給一個物件附加額外的功能，這也是子類的一種替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。
		* 享元模式：使用快取來加速大量小物件的訪問時間，如 valueOf(int)。
		* 代理模式：代理模式是用一個簡單的物件來代替一個複雜的或者建立耗時的物件，如 java.lang.reflect.Proxy

	* 建立模式:
		* 抽象工廠模式：抽象工廠模式提供了一個協議來生成一系列的相關或者獨立的物件，而不用指定具體物件的型別，如 java.util.Calendar#getInstance()。
		* 建造模式(Builder)：定義了一個新的類來構建另一個類的例項，以簡化複雜物件的建立，如：java.lang.StringBuilder#append()。
		* 工廠方法：就是 **一個返*** 回具體物件的方法，而不是多個，如 java.lang.Object#toString()、java.lang.Class#newInstance()。
		* 原型模式：使得類的例項能夠生成自身的拷貝、如：java.lang.Object#clone()。
		* 單例模式：全域性只有一個例項，如 java.lang.Runtime#getRuntime()。
	* 行為模式：
		* 責任鏈模式：通過把請求從一個物件傳遞到鏈條中下一個物件的方式，直到請求被處理完畢，以實現物件間的解耦。如 javax.servlet.Filter#doFilter()。
		* 命令模式：將操作封裝到物件內，以便儲存，傳遞和返回，如：java.lang.Runnable。
		* 直譯器模式：定義了一個語言的語法，然後解析相應語法的語句，如，java.text.Format，java.text.Normalizer。
		* 迭代器模式：提供一個一致的方法來順序訪問集合中的物件，如 java.util.Iterator。
		* 中介者模式：通過使用一箇中間物件來進行訊息分發以及減少類之間的直接依賴，java.lang.reflect.Method#invoke()。
		* 空物件模式：如 java.util.Collections#emptyList()。
		* 觀察者模式：它使得一個物件可以靈活的將訊息傳送給感興趣的物件，如 java.util.EventListener。
		* 模板方法模式：讓子類可以重寫方法的一部分，而不是整個重寫，如 java.util.Collections#sort()。

* [《Spring-涉及到的設計模式彙總》](https://www.cnblogs.com/hwaggLee/p/4510687.html)
* [《Mybatis使用的設計模式》](https://blog.csdn.net/u012387062/article/details/54719114)

## 單例模式
* [《單例模式的三種實現 以及各自的優缺點》](https://blog.csdn.net/YECrazy/article/details/79481964)
* [《單例模式－－反射－－防止序列化破壞單例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)
	* 使用列舉型別。

## 責任鏈模式
TODO

## MVC
* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)
	* 模型(model)－檢視(view)－控制器(controller)

## IOC
* [《理解 IOC》](https://www.zhihu.com/question/23277575)
* [《IOC 的理解與解釋》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)
	* 正向控制：傳統通過new的方式。反向控制，通過容器注入物件。
	* 作用：用於模組解耦。
	* DI：Dependency Injection，即依賴注入，只關心資源使用，不關心資源來源。

## AOP

* [《輕鬆理解AOP(面向切面程式設計)》](https://my.oschina.net/yanquan345/blog/203415)
* [《Spring AOP詳解》](https://www.cnblogs.com/hongwz/p/5764917.html)
* [《Spring AOP的實現原理》](http://www.importnew.com/24305.html)
	* Spring AOP使用的動態代理，主要有兩種方式：JDK動態代理和CGLIB動態代理。
* [《Spring AOP 實現原理與 CGLIB 應用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)
	* Spring AOP 框架對 AOP 代理類的處理原則是：如果目標物件的實現類實現了介面，Spring AOP 將會採用 JDK 動態代理來生成 AOP 代理類；如果目標物件的實現類沒有實現介面，Spring AOP 將會採用 CGLIB 來生成 AOP 代理類


## UML

* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)

## 微服務思想
* [《微服務架構設計》](https://www.cnblogs.com/wintersun/p/6219259.html)
### 康威定律
* [《微服務架構的理論基礎 - 康威定律》](https://yq.aliyun.com/articles/8611)
	* 定律一：組織溝通方式會通過系統設計表達出來，就是說架構的佈局和組織結構會有相似。
	* 定律二：時間再多一件事情也不可能做的完美，但總有時間做完一件事情。一口氣吃不成胖子，先搞定能搞定的。
	* 定律三：線型系統和線型組織架構間有潛在的異質同態特性。種瓜得瓜，做獨立自治的子系統減少溝通成本。
	* 定律四：大的系統組織總是比小系統更傾向於分解。合久必分，分而治之。

* [《微服務架構核⼼20講》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)

# 運維 & 統計 & 技術支援

## 常規監控

* [《騰訊業務系統監控的修煉之路》](https://blog.csdn.net/enweitech/article/details/77849205)
	* 監控的方式：主動、被動、旁路(比如輿情監控)
	* 監控型別： 基礎監控、服務端監控、客戶端監控、
	監控、使用者端監控
	* 監控的目標：全、塊、準
	* 核心指標：請求量、成功率、耗時

* [《開源還是商用？十大雲運維監控工具橫評》](https://www.oschina.net/news/67525/monitoring-tools)
	* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、監控寶、 360網站服務監控、阿里雲監控、百度雲觀測、小蜜蜂網站監測等。

* [《監控報警系統搭建及二次開發經驗》](http://developer.51cto.com/art/201612/525373.htm)

**命令列監控工具**

* [《常用命令列監控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)
	* top、sar、tsar、nload

* [《20個命令列工具監控 Linux 系統效能》](http://blog.jobbole.com/96846/)

* [《JVM效能調優監控工具jps、jstack、jmap、jhat、jstat、hprof使用詳解》](https://my.oschina.net/feichexia/blog/196575)

## APM

APM —  Application Performance Management

* [《Dapper，大規模分散式系統的跟蹤系統》](http://bigbully.github.io/Dapper-translation/)

* [《開源APM技術選型與實戰》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)
	* 主要基於 Google的Dapper（大規模分散式系統的跟蹤系統） 思想。
	* 開源軟體有：Pinpoint、SkyWalking、Zipkin、CAT


## 統計分析

* [《流量統計的基礎：埋點》](https://zhuanlan.zhihu.com/p/25195217)
	* 常用指標：訪問與訪客、停留時長、跳出率、退出率、轉化率、參與度

* [《APP埋點常用的統計工具、埋點目標和埋點內容》](http://www.25xt.com/company/17066.html)
	* 第三方統計：友盟、百度移動、魔方、App Annie、talking data、神策資料等。

* [《美團點評前端無痕埋點實踐》](https://tech.meituan.com/mt-mobile-analytics-practice.html)
	* 所謂無痕、即通過視覺化工具配置採集節點，在前端自動解析配置並上報埋點資料，而非硬編碼。


## 持續整合(CI/CD)

* [《持續整合是什麼？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)
* [《8個流行的持續整合工具》](https://www.testwo.com/article/1170)

### Jenkins

* [《使用Jenkins進行持續整合》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)

### 環境分離

開發、測試、生成環境分離。

* [《開發環境、生產環境、測試環境的基本理解和區》](https://my.oschina.net/sancuo/blog/214904)

## 自動化運維

### Ansible
* [《Ansible中文權威指南》](http://www.ansible.com.cn/)
* [《Ansible基礎配置和企業級專案實用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)

### puppet
* [《自動化運維工具——puppet詳解》](https://www.cnblogs.com/keerya/p/8040071.html)

### chef
* [《Chef 的安裝與使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)

## 測試

### TDD 理論

* [《深度解讀 - TDD（測試驅動開發）》](https://www.jianshu.com/p/62f16cd4fef3)
	* 基於測試用例編碼功能程式碼，XP（Extreme Programming）的核心實踐.
	* 好處：一次關注一個點，降低思維負擔；迎接需求變化或改善程式碼的設計；提前澄清需求；快速反饋；

### 單元測試

* [《Java單元測試之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)
* [《JUnit 4 與 TestNG 對比》](https://blog.csdn.net/hotdust/article/details/53406086)
	* TestNG 覆蓋 JUnit 功能，適用於更復雜的場景。
* [《單元測試主要的測試功能點》](https://blog.csdn.net/wqetfg/article/details/50900512)
	* 模組介面測試、區域性資料結構測試、路徑測試 、錯誤處理測試、邊界條件測試 。

### 壓力測試

* [《Apache ab 測試使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)
* [《大型網站壓力測試及優化方案》](https://www.cnblogs.com/binyue/p/6141088.html)
* [《10大主流壓力/負載/效能測試工具推薦》](http://news.chinabyte.com/466/14126966.shtml)
* [《真實流量壓測工具 tcpcopy應用淺析》](http://quentinxxz.iteye.com/blog/2249799)
* [《nGrinder 簡易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)


### 全鏈路壓測
* [《京東618：升級全鏈路壓測方案，打造軍演機器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)
* [《餓了麼全鏈路壓測的探索與實踐》](https://zhuanlan.zhihu.com/p/30306892)
* [《四大語言，八大框架｜滴滴全鏈路壓測解決之道》](https://zhuanlan.zhihu.com/p/28355759)
* [《全鏈路壓測經驗》](https://www.jianshu.com/p/27060fd61f72)


### A/B Test

* [《技術乾貨 | AB 測試和灰度釋出探索及實踐》](https://testerhome.com/topics/11165)
* [《nginx 根據IP 進行灰度釋出》](http://blog.51cto.com/purplegrape/1403123)


## 虛擬化

* [《VPS的三種虛擬技術OpenVZ、Xen、KVM優缺點比較》](https://blog.csdn.net/enweitech/article/details/52910082)

### KVM
* [《KVM詳解，太詳細太深入了，經典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)
* [《【圖文】KVM 虛擬機器安裝詳解》](https://www.coderxing.com/kvm-install.html)

### Xen
* [《Xen虛擬化基本原理詳解》](https://www.cnblogs.com/sddai/p/5931201.html)

### OpenVZ
* [《開源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)

## 容器技術

### Docker
* [《幾張圖幫你理解 docker 基本原理及快速入門》](https://www.cnblogs.com/SzeCheng/p/6822905.html)
* [《Docker 核心技術與實現原理》](https://draveness.me/docker)
* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)

## 雲技術

### OpenStack
* [《OpenStack構架知識梳理》](https://www.cnblogs.com/klb561/p/8660264.html)

## DevOps
* [《一分鐘告訴你究竟DevOps是什麼鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)
* [《DevOps詳解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)

## 文件管理

* [Confluence-收費文件管理系統](http://www.confluence.cn/)
* GitLab?
* Wiki

# 中介軟體

## Web Server

### Nginx
* [《Ngnix的基本學習-多程序和Apache的比較》](https://blog.csdn.net/qq_25797077/article/details/52200722)
	* Nginx 通過非同步非阻塞的事件處理機制實現高併發。Apache 每個請求獨佔一個執行緒，非常消耗系統資源。
	* 事件驅動適合於IO密集型服務(Nginx)，多程序或執行緒適合於CPU密集型服務(Apache)，所以Nginx適合做反向代理，而非web伺服器使用。  

* [《nginx與Apache的對比以及優缺點》](https://www.cnblogs.com/cunkouzh/p/5410154.html)
	* nginx只適合靜態和反向代理，不適合處理動態請求。

### OpenResty
* [官方網站](http://openresty.org/cn/)
* [《淺談 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)
	* 通過 Lua 模組可以在Nginx上進行開發。

### Apache Httpd
* [官方網站](http://httpd.apache.org/)

### Tomcat

#### 架構原理
* [《TOMCAT原理詳解及請求過程》](https://www.cnblogs.com/hggen/p/6264475.html)
* [《Tomcat伺服器原理詳解》](https://www.cnblogs.com/crazylqy/p/4706223.html)
* [《Tomcat 系統架構與設計模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)

* [《四張圖帶你瞭解Tomcat系統架構》](https://blog.csdn.net/xlgen157387/article/details/79006434)

* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)
	* Tomcat 是輕量級的 Serverlet 容器，沒有實現全部 JEE 特性（比如持久化和事務處理），但可以通過其他元件代替，比如Srping。
	* Jboss 實現全部了JEE特性，軟體開源免費、文件收費。

#### 調優方案

* [《Tomcat 調優方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)
	* 啟動NIO模式（或者APR）；調整執行緒池；禁用AJP聯結器（Nginx+tomcat的架構，不需要AJP）；

* [《tomcat http協議與ajp協議》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)
* [《AJP與HTTP比較和分析》](http://dmouse.iteye.com/blog/1354527)
	* AJP 協議（8009埠）用於降低和前端Server（如Apache，而且需要支援AJP協議）的連線數(前端)，通過長連線提高效能。
	* 併發高時，AJP協議優於HTTP協議。

### Jetty
* [《Jetty 的工作原理以及與 Tomcat 的比較》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)
* [《jetty和tomcat優勢比較》](https://blog.csdn.net/doutao6677/article/details/51957288)
	* 架構比較:Jetty的架構比Tomcat的更為簡單。
	* 效能比較：Jetty和Tomcat效能方面差異不大，Jetty預設採用NIO結束在處理I/O請求上更佔優勢，Tomcat預設採用BIO處理I/O請求，Tomcat適合處理少數非常繁忙的連結，處理靜態資源時效能較差。
	* 其他方面：Jetty的應用更加快速，修改簡單，對新的Servlet規範的支援較好;Tomcat 對JEE和Servlet 支援更加全面。



## 快取

* [《快取失效策略（FIFO 、LRU、LFU三種演算法的區別）》](https://blog.csdn.net/clementad/article/details/48229243)

### 本地快取

* [《HashMap本地快取》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)

* [《EhCache本地快取》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)
	* 堆內、堆外、磁碟三級快取。
	* 可按照快取空間容量進行設定。
	* 按照時間、次數等過期策略。

* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)
	* 簡單輕量、無堆外、磁碟快取。

* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)
	* 簡單輕量、無堆外、磁碟快取。

* [《Nginx本地快取》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)

* [《Pagespeed—懶人工具，伺服器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)

## 客戶端快取

* [《瀏覽器端快取》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)
	* 主要是利用 Cache-Control 引數。

* [《H5 和移動端 WebView 快取機制解析與實戰》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)

### Memcached
* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)
* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)
	* 採用多路複用技術提高併發性。
	* slab分配演算法： memcached給Slab分配記憶體空間，預設是1MB。分配給Slab之後 把slab的切分成大小相同的chunk，Chunk是用於快取記錄的記憶體空間，Chunk 的大小預設按照1.25倍的速度遞增。好處是不會頻繁申請記憶體，提高IO效率，壞處是會有一定的記憶體浪費。
* [《Memcached軟體工作原理》](https://www.jianshu.com/p/36e5cd400580)
* [《Memcache技術分享：介紹、使用、儲存、演算法、優化、命中率》](http://zhihuzeye.com/archives/2361)

* [《memcache 中 add 、 set 、replace 的區別》](https://blog.csdn.net/liu251890347/article/details/37690045)
	* 區別在於當key存在還是不存在時，返回值是true和false的。

* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)

### Redis

* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)
* [《redis底層原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)
	* 使用 ziplist 儲存連結串列，ziplist是一種壓縮連結串列，它的好處是更能節省記憶體空間，因為它所儲存的內容都是在連續的記憶體區域當中的。
	* 使用 skiplist(跳躍表)來儲存有序集合物件、查詢上先從高Level查起、時間複雜度和紅黑樹相當，實現容易，無鎖、併發性好。
* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)
	* RDB方式：定期備份快照，常用於災難恢復。優點：通過fork出的程序進行備份，不影響主程序、RDB 在恢復大資料集時的速度比 AOF 的恢復速度要快。缺點：會丟資料。
	* AOF方式：儲存操作日誌方式。優點：恢復時資料丟失少，缺點：檔案大，回覆慢。
	* 也可以兩者結合使用。

* [《分散式快取--序列3--原子操作與CAS樂觀鎖》](https://blog.csdn.net/chunlongyu/article/details/53346436)

#### 架構
* [《Redis單執行緒架構》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)

#### 回收策略
* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)

### Tair

* [官方網站](https://github.com/alibaba/tair)
* [《Tair和Redis的對比》](http://blog.csdn.net/farphone/article/details/53522383)
* 特點：可以配置備份節點數目，通過非同步同步到備份節點
* 一致性Hash演算法。
* 架構：和Hadoop 的設計思想類似，有Configserver，DataServer，Configserver 通過心跳來檢測，Configserver也有主備關係。


幾種儲存引擎:
* MDB，完全記憶體性，可以用來儲存Session等資料。
* Rdb（類似於Redis），輕量化，去除了aof之類的操作，支援Restfull操作
* LDB（LevelDB儲存引擎），持久化儲存，LDB 作為rdb的持久化，google實現，比較高效，理論基礎是LSM(Log-Structured-Merge Tree)演算法，現在記憶體中修改資料，達到一定量時（和記憶體彙總的舊資料一同寫入磁碟）再寫入磁碟，儲存更加高效，縣比喻Hash演算法。
* Tair採用共享記憶體來儲存資料，如果服務掛掉（非伺服器），重啟服務之後，資料亦然還在。

## 訊息佇列

* [《訊息佇列-推/拉模式學習 & ActiveMQ及JMS學習》](https://www.cnblogs.com/charlesblc/p/6045238.html)
	* RabbitMQ 消費者預設是推模式（也支援拉模式）。
	* Kafka 預設是拉模式。
	* Push方式：優點是可以儘可能快地將訊息傳送給消費者，缺點是如果消費者處理能力跟不上，消費者的緩衝區可能會溢位。
	* Pull方式：優點是消費端可以按處理能力進行拉去，缺點是會增加訊息延遲。

* [《Kafka、RabbitMQ、RocketMQ等訊息中介軟體的對比 —— 訊息傳送效能和區別》](https://blog.csdn.net/yunfeng482/article/details/72856762)

### 訊息匯流排

訊息匯流排相當於在訊息佇列之上做了一層封裝，統一入口，統一管控、簡化接入成本。

* [《訊息匯流排VS訊息佇列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)

### 訊息的順序
* [《如何保證消費者接收訊息的順序》](https://www.cnblogs.com/cjsblog/p/8267892.html)

### RabbitMQ

支援事務，推拉模式都是支援、適合需要可靠性訊息傳輸的場景。

* [《RabbitMQ的應用場景以及基本原理介紹》](https://blog.csdn.net/whoamiyang/article/details/54954780)
* [《訊息佇列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57)
* [《RabbitMQ之訊息確認機制（事務+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)

### RocketMQ
Java實現，推拉模式都是支援，吞吐量遜於Kafka。可以保證訊息順序。
* [《RocketMQ 實戰之快速入門》](https://www.jianshu.com/p/824066d70da8)

### ActiveMQ
純Java實現，相容JMS，可以內嵌於Java應用中。
* [《ActiveMQ訊息佇列介紹》](https://www.cnblogs.com/wintersun/p/3962302.html)

### Kafka
高吞吐量、採用拉模式。適合搞IO場景，比如日誌同步。

* [官方網站](http://kafka.apache.org/)
* [《各訊息佇列對比，Kafka深度解析，眾人推薦，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)
* [《Kafka分割槽機制介紹與示例》](http://lxw1234.com/archives/2015/10/538.htm)

### Redis 訊息推送

生產者、消費者模式完全是客戶端行為，list 和 拉模式實現，阻塞等待採用 blpop 指令。

* [《Redis學習筆記之十：Redis用作訊息佇列》](https://blog.csdn.net/qq_34212276/article/details/78455004)

### ZeroMQ
 TODO


## 定時排程

### 單機定時排程

* [《linux定時任務cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)

* [《Linux cron執行原理》](https://my.oschina.net/daquan/blog/483305)
	* fork 程序 + sleep 輪詢

* [《Quartz使用總結》](https://www.cnblogs.com/drift-ice/p/3817269.html)
* [《Quartz原始碼解析 ---- 觸發器按時啟動原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)
* [《quartz原理揭祕和原始碼解讀》](https://www.jianshu.com/p/bab8e4e32952)
	* 定時排程在 QuartzSchedulerThread 程式碼中，while()無限迴圈，每次迴圈取出時間將到的trigger，觸發對應的job，直到排程器執行緒被關閉。


### 分散式定時排程

* [《這些優秀的國產分散式任務排程系統，你用過幾個？》](https://blog.csdn.net/qq_16216221/article/details/70314337)
	* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares

* [《Quartz任務排程的基本實現原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)
	* Quartz叢集中，獨立的Quartz節點並不與另一其的節點或是管理節點通訊，而是通過相同的資料庫表來感知到另一Quartz應用的


## RPC

* [《從零開始實現RPC框架 - RPC原理及實現》](https://blog.csdn.net/top_code/article/details/54615853)
	* 核心角色：Server: 暴露服務的服務提供方、Client: 呼叫遠端服務的服務消費方、Registry: 服務註冊與發現的註冊中心。

* [《分散式RPC框架效能大比拼 dubbo、motan、rpcx、gRPC、thrift的效能比較》](https://blog.csdn.net/testcs_dn/article/details/78050590)

### Dubbo
* [官方網站](http://dubbo.apache.org/)
* [dubbo實現原理簡單介紹](https://www.cnblogs.com/steven520213/p/7606598.html)

** SPI **
TODO

### Thrift
* [官方網站](http://thrift.apache.org/)
* [《Thrift RPC詳解》](https://blog.csdn.net/kesonyk/article/details/50924489)
	* 支援多語言，通過中間語言定義介面。

### gRPC

服務端可以認證加密，在外網環境下，可以保證資料安全。

* [官方網站](https://grpc.io/)
* [《你應該知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)


## 資料庫中介軟體

### Sharding Jdbc

* [官網](http://shardingjdbc.io/)

## 日誌系統

### 日誌蒐集

* [《從零開始搭建一個ELKB日誌收集系統》](http://cjting.me/misc/build-log-system-with-elkb/)
* [《用ELK搭建簡單的日誌收集分析系統》](https://blog.csdn.net/lzw_2006/article/details/51280058)
* [《日誌收集系統-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)

## 配置中心

* [Apollo - 攜程開源的配置中心應用](https://github.com/ctripcorp/apollo)
	* Spring Boot 和 Spring Cloud
	* 支援推、拉模式更新配置
	* 支援多種語言

* [《基於zookeeper實現統一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)

* [《 Spring Cloud Config 分散式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)

servlet 3.0 非同步特性可用於配置中心的客戶端
* [《servlet3.0 新特性——非同步處理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)

## API 閘道器

主要職責：請求轉發、安全認證、協議轉換、容災。

* [《API閘道器那些兒》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)
* [《談API閘道器的背景、架構以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)

* [《使用Zuul構建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)
* [《HTTP API閘道器選擇之一Kong介紹》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)

# 網路


## 協議

### OSI 七層協議

* [《OSI七層協議模型、TCP/IP四層模型學習筆記》](https://www.cnblogs.com/Robin-YB/p/6668762.html)

### TCP/IP
* [《深入淺出 TCP/IP 協議》](https://www.cnblogs.com/onepixel/p/7092302.html)
* [《TCP協議中的三次握手和四次揮手》](https://blog.csdn.net/whuslei/article/details/6667471/)

### HTTP
* [《http協議詳解(超詳細)》](https://www.cnblogs.com/wangning528/p/6388464.html)

### HTTP2.0
* [《HTTP 2.0 原理詳細分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)
* [《HTTP2.0的基本單位為二進位制幀》](https://blog.csdn.net/u012657197/article/details/77877840)
	* 利用二進位制幀負責傳輸。
	* 多路複用。

### HTTPS
* [《https原理通俗瞭解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)
	* 使用非對稱加密協商加密演算法
	* 使用對稱加密方式傳輸資料
	* 使用第三方機構簽發的證書，來加密公鑰，用於公鑰的安全傳輸、防止被中間人串改。

* [《八大免費SSL證書-給你的網站免費新增Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)

## 網路模型

* [《web優化必須瞭解的原理之I/o的五種模型和web的三種工作模式》](http://blog.51cto.com/litaotao/1289790)
	* 五種I/O模型：阻塞I/O，非阻塞I/O，I/O複用、事件(訊號)驅動I/O、非同步I/O，前四種I/O屬於同步操作，I/O的第一階段不同、第二階段相同，最後的一種則屬於非同步操作。
	* 三種 Web Server 工作方式：Prefork(多程序)、Worker方式(執行緒方式)、Event方式。

* [《select、poll、epoll之間的區別總結》](http://www.cnblogs.com/Anker/p/3265058.html)
	* select，poll，epoll本質上都是同步I/O，因為他們都需要在讀寫事件就緒後自己負責進行讀寫，也就是說這個讀寫過程是阻塞的。
	* select 有開啟檔案描述符數量限制，預設1024（2048 for x64），100萬併發，就要用1000個程序、切換開銷大；poll採用連結串列結構，沒有數量限制。
	* select，poll “醒著”的時候要遍歷整個fd集合，而epoll在“醒著”的時候只要判斷一下就緒連結串列是否為空就行了，通過回撥機制節省大量CPU時間；select，poll每次呼叫都要把fd集合從使用者態往核心態拷貝一次，而epoll只要一次拷貝。
	* poll會隨著併發增加，效能逐漸下降，epoll採用紅黑樹結構，效能穩定，不會隨著連線數增加而降低。

* [《select，poll，epoll比較  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)
	* 在連線數少並且連線都十分活躍的情況下，select和poll的效能可能比epoll好，畢竟epoll的通知機制需要很多函式回撥。

* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)
	* NIO 是一種同步非阻塞的 IO 模型。同步是指執行緒不斷輪詢 IO 事件是否就緒，非阻塞是指執行緒在等待 IO 的時候，可以同時做其他任務

* [《BIO與NIO、AIO的區別》](https://blog.csdn.net/skiof007/article/details/52873421)

* [《兩種高效的伺服器設計模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)

### Epoll

* [《epoll使用詳解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)

### Java NIO
* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)
* [《Java NIO編寫Socket伺服器的一個例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)

### kqueue
* [《kqueue用法簡介》](http://www.cnblogs.com/luminocean/p/5631336.html)

## 連線和短連線

* [《TCP/IP系列——長連線與短連線的區別》](https://www.cnblogs.com/pangguoping/p/5571422.html)

## 框架

* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)
	* Reactor 模式介紹。
	* Netty 是 Reactor 模式的一種實現。

## 零拷貝（Zero-copy）
* [《對於 Netty ByteBuf 的零拷貝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)
	* 多個物理分離的buffer，通過邏輯上合併成為一個，從而避免了資料在記憶體之間的拷貝。

## 序列化(二進位制協議)

### Hessian
* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)
Binary-RPC;不僅僅是序列化

### Protobuf
* [《Protobuf協議的Java應用例子》](https://blog.csdn.net/antgan/article/details/52103966)
Goolge出品、佔用空間和效率完勝其他序列化類庫，如Hessian；需要編寫  .proto 檔案。
* [《Protocol Buffers序列化協議及應用》](https://worktile.com/tech/share/prototol-buffers)
  關於協議的解釋；缺點：可讀性差;


# 資料庫
## 基礎理論
### 資料庫設計的三大正規化
* [《資料庫的三大正規化以及五大約束》](https://www.cnblogs.com/waj6511988/p/7027127.html)
	* 第一正規化：資料表中的每一列（每個欄位）必須是不可拆分的最小單元，也就是確保每一列的原子性；
	* 第二正規化（2NF）：滿足1NF後，要求表中的所有列，都必須依賴於主鍵，而不能有任何一列與主鍵沒有關係，也就是說一個表只描述一件事情；
	* 第三正規化：必須先滿足第二正規化（2NF），要求：表中的每一列只與主鍵直接相關而不是間接相關，（表中的每一列只能依賴於主鍵）；

## MySQL

### 原理
* [《MySQL的InnoDB索引原理詳解》](http://www.admin10000.com/document/5372.html)

* [《MySQL儲存引擎－－MyISAM與InnoDB區別》](https://blog.csdn.net/xifeijian/article/details/20316775)
	* 兩種型別最主要的差別就是Innodb 支援事務處理與外來鍵和行級鎖

* [《myisam和innodb索引實現的不同》](https://www.2cto.com/database/201211/172380.html)

### InnoDB

* [《一篇文章帶你讀懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)

### 優化

* [《MySQL36條軍規》](http://vdisk.weibo.com/s/muWOT)

* [《MYSQL效能優化的最佳20+條經驗》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)
* [《SQL優化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)
* [《mysql資料庫死鎖的產生原因及解決辦法》](https://www.cnblogs.com/sivkun/p/7518540.html)
* [《導致索引失效的可能情況》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)
* [《 MYSQL分頁limit速度太慢優化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)
	* 原則上就是縮小掃描範圍。


### 索引

#### 聚集索引, 非聚集索引

* [《MySQL 聚集索引/非聚集索引簡述》](https://blog.csdn.net/no_endless/article/details/77073549)
* [《MyISAM和InnoDB的索引實現》](https://www.cnblogs.com/zlcxbb/p/5757245.html)

MyISAM 是非聚集，InnoDB 是聚集

#### 複合索引

* [《複合索引的優點和注意事項》](https://www.cnblogs.com/summer0space/p/7247778.html)

#### 自適應雜湊索引(AHI)

* [《InnoDB儲存引擎——自適應雜湊索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)


### explain
* [《MySQL 效能優化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)

## NoSQL

### MongoDB

* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)
* [《Mongodb相對於關係型資料庫的優缺點》](http://mxdxm.iteye.com/blog/2093603)
	* 優點：弱一致性（最終一致），更能保證使用者的訪問速度；內建GridFS，支援大容量的儲存；Schema-less 資料庫，不用預先定義結構；內建Sharding；相比於其他NoSQL，第三方支援豐富；效能優越；
	* 缺點：mongodb不支援事務操作；mongodb佔用空間過大；MongoDB沒有如MySQL那樣成熟的維護工具，這對於開發和IT運營都是個值得注意的地方；

### Hbase

* [《簡明 HBase 入門教程（開篇）》](http://www.thebigdata.cn/HBase/35831.html)
* [《深入學習HBase架構原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)
* [《傳統的行儲存和（HBase）列儲存的區別》](https://blog.csdn.net/youzhouliu/article/details/67632882)


* [《Hbase與傳統資料庫的區別》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)
	* 空資料不儲存，節省空間，且適用於併發。

* [《HBase Rowkey設計》](https://blog.csdn.net/u014091123/article/details/73163088)
	* rowkey 按照字典順序排列，便於批量掃描。
	* 通過雜湊可以避免熱點。

# 搜尋引擎

## 搜尋引擎原理

* [《倒排索引--搜尋引擎入門》](https://www.jianshu.com/p/0193dc44135b)

## Lucene
* [《Lucene入門簡介》](https://www.cnblogs.com/rodge-run/p/6551152.html)

## Elasticsearch

* [《Elasticsearch學習，請先看這一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)
* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)

## Solr
* [《 Apache Solr入門教程》](https://blog.csdn.net/u011936655/article/details/51960005)
* [《elasticsearch與solr比較》](https://blog.csdn.net/convict_eva/article/details/53537837)

## sphinx
* [《Sphinx 的介紹和原理探索》](http://blog.jobbole.com/101672/)

# 效能

## 效能優化方法論

* [《15天的效能優化工作，5方面的調優經驗》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)
	* 程式碼層面、業務層面、資料庫層面、伺服器層面、前端優化。

* [《系統效能優化的幾個方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)

## 容量評估
* [《聯網效能與容量評估的方法論和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)

## CDN 網路

* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)
* [《國內有哪些比較好的 CDN？》](https://www.zhihu.com/question/20536932)

## 連線池

* [《主流Java資料庫連線池比較與開發配置實戰》](https://blog.csdn.net/fysuccess/article/details/66972554)

## 效能調優

* [《九大Java效能除錯工具，必備至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)


# 大資料

## 流式計算

### Storm
* [官方網站](http://storm.apache.org/)
* [《最詳細的Storm入門教程》](https://blog.csdn.net/uisoul/article/details/77989927)

### Flink
* [《Flink之一 Flink基本原理介紹》](https://blog.csdn.net/lisi1129/article/details/54844919)

### Kafka Stream
* [《Kafka Stream調研：一種輕量級流計算模式》](https://yq.aliyun.com/articles/58382)

### 應用場景

例如：

* 廣告相關實時統計；
* 推薦系統使用者畫像標籤實時更新；
* 線上服務健康狀況實時監測；
* 實時榜單；
* 實時資料統計。

## Hadoop

* [《用通俗易懂的話說下hadoop是什麼,能做什麼》](https://blog.csdn.net/houbin0912/article/details/72967178)
* [《史上最詳細的Hadoop環境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)

### HDFS
* [《【Hadoop學習】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)

### MapReduce
* [《用通俗易懂的大白話講解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)
* [《 簡單的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)

### Yarn
* [《初步掌握Yarn的架構及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)

## Spark
* [《Spark(一): 基本架構及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)


# 安全

## web 安全

### XSS
* [《xss攻擊原理與解決方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)
### CSRF
* [《CSRF原理及防範》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)

### SQL 注入

* [《SQL隱碼攻擊》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)

### Hash Dos


* [《邪惡的JAVA HASH DOS攻擊》](http://www.freebuf.com/articles/web/14199.html)
	* 利用JsonObjet 上傳大Json，JsonObject 底層使用HashMap；不同的資料產生相同的hash值，使得構建Hash速度變慢，耗盡CPU。
* [《一種高階的DoS攻擊-Hash碰撞攻擊》](https://yq.aliyun.com/articles/92194?t=t1)
* [《關於Hash Collision DoS漏洞：解析與解決方案》](http://www.iteye.com/news/23939/)

### 指令碼注入

* [《上傳檔案漏洞原理及防範》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)

### 漏洞掃描工具
* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)
* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)
* [OpenVAS詳解](https://blog.csdn.net/xygg0801/article/details/53610640)

### 驗證碼

* [《驗證碼原理分析及實現》](https://blog.csdn.net/niaonao/article/details/51112686)

* [《詳解滑動驗證碼的實現原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)
	* 滑動驗證碼是根據人在滑動滑塊的響應時間，拖拽速度，時間，位置，軌跡，重試次數等來評估風險。

* [《淘寶滑動驗證碼研究》](https://www.cnblogs.com/xcj26/p/5242758.html)

## DDoS 防範
* [《學習手冊：DDoS的攻擊方式及防禦手段》](http://netsecurity.51cto.com/art/201601/503799.htm)
* [《免費DDoS攻擊測試工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)

## 使用者隱私資訊保護

1. 使用者密碼非明文儲存，加動態slat。
2. 身份證號，手機號如果要顯示，用 “\*” 替代部分字元。
3. 聯絡方式在的顯示與否由使用者自己控制。
4. TODO

* [《個人隱私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)
* [《在網際網路上，隱私的範圍包括哪些？》](https://www.zhihu.com/question/20137108)

* [《使用者密碼儲存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)

## 加密解密

### 對稱加密

* [《常見對稱加密演算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)
	* DES、3DES、Blowfish、AES
	* DES 採用 56位祕鑰，Blowfish 採用1到448位變長祕鑰，AES 128，192和256位長度的祕鑰。
	* DES 祕鑰太短（只有56位）演算法目前已經被 AES 取代，並且 AES 有硬體加速，效能很好。

### 雜湊演算法
* [《常用的雜湊演算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)
	* MD5 和 SHA-1 已經不再安全，已被棄用。
	* 目前 SHA-256 是比較安全的。

* [《基於Hash摘要簽名的公網URL簽名驗證設計方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)

### 非對稱加密
* [《常見非對稱加密演算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)
	* RSA、DSA、ECDSA(螺旋曲線加密演算法)
	* 和 RSA 不同的是 DSA 僅能用於數字簽名，不能進行資料加密解密，其安全性和RSA相當，但其效能要比RSA快。
	* 256位的ECC祕鑰的安全性等同於3072位的RSA祕鑰。

		[《區塊鏈的加密技術》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)


## 伺服器安全
* [《Linux強化論：15步打造一個安全的Linux伺服器》](http://www.freebuf.com/articles/system/121540.html)

## 資料安全

### 資料備份

TODO

## 網路隔離

### 內外網分離

TODO

### 登入跳板機
在內外環境中通過跳板機登入到線上主機。
* [《搭建簡易堡壘機》](http://blog.51cto.com/zero01/2062618)

## 授權、認證
### RBAC
* [《基於組織角色的許可權設計》](https://www.cnblogs.com/zq8024/p/5003050.html)
* [《許可權系統與RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)
* [《Spring整合Shiro做許可權控制模組詳細案例分析》](https://blog.csdn.net/he90227/article/details/38663553)

### OAuth2.0
* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

### 雙因素認證（2FA）

2FA - Two-factor authentication，用於加強登入驗證

常用做法是 登入密碼 + 手機驗證碼（或者令牌Key，類似於與網銀的 USB key）

* 【《雙因素認證（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)

### 單點登入(SSO)

* [《單點登入原理與簡單實現》](https://www.cnblogs.com/ywlaker/p/6113927.html)

* [CAS單點登入框架](https://github.com/apereo/cas)

# 常用開源框架

## 開源協議

* [《開原協議的選擇》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)

## 日誌框架

### Log4j、Log4j2
* [《log4j 詳細講解》](https://blog.csdn.net/u012422446/article/details/51199724)
* [《log4j2 實際使用詳解》](https://blog.csdn.net/vbirdbest/article/details/71751835)
* [《Log4j1,Logback以及Log4j2效能測試對比》](https://my.oschina.net/OutOfMemory/blog/789267)
	* Log4J 非同步日誌效能優異。

### Logback
* [《最全LogBack 詳解、含java案例和配置說明》](https://blog.csdn.net/rulon147/article/details/52620541)

## ORM

* [《ORM框架使用優缺點》](https://blog.csdn.net/sinat_34093604/article/details/53082000)
	* 主要目的是為了提高開發效率。

**MyBatis：**

* [《mybatis快取機制詳解》](https://www.cnblogs.com/winclpt/articles/7511672.html)
	* 一級快取是SqlSession級別的快取，快取的資料只在SqlSession內有效
	* 二級快取是mapper級別的快取，同一個namespace公用這一個快取，所以對SqlSession是共享的；使用 LRU 機制清理快取，通過 cacheEnabled 引數開啟。  

* [《MyBatis學習之程式碼生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)

## 網路框架

TODO

## Web 框架

### Spring 家族
**Spring**
* [Spring 簡明教程](https://www.w3cschool.cn/wkspring/)

**Spring Boot**
* [官方網站](http://projects.spring.io/spring-boot/)
* [Spring Boot 參考指南(中文)](http://oopsguy.com/documents/springboot-docs/1.5.4/index.html)

**Spring Cloud**
* [Spring Cloud 中文文件](https://springcloud.cc/)


## 工具框架

* [《Apache Commons 工具類介紹及簡單使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)
* [《Google guava 中文教程》](http://ifeve.com/google-guava/)


# 分散式設計

## 擴充套件性設計

* [《架構師不可不知的十大可擴充套件架構》](https://blog.csdn.net/hemin1003/article/details/53633926)
	* 總結下來，通用的套路就是分佈、快取及非同步處理。

* [《可擴充套件性設計之資料切分》](https://yq.aliyun.com/articles/38119)
	* 水平切分+垂直切分
	* 利用中介軟體進行分片如，MySQL Proxy。
	* 利用分片策略進行切分，如按照ID取模。
* [《說說如何實現可擴充套件性的大型網站架構》](https://blog.csdn.net/deniro_li/article/details/78458306)
	* 分散式服務+訊息佇列。

* [《大型網站技術架構（七）--網站的可擴充套件性架構》](https://blog.csdn.net/chaofanwei/article/details/29191073)

## 穩定性 & 高可用

* [《系統設計：關於高可用系統的一些技術方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)
	* 可擴充套件：水平擴充套件、垂直擴充套件。 通過冗餘部署，避免單點故障。
	* 隔離：避免單一業務佔用全部資源。避免業務之間的相互影響 2. 機房隔離避免單點故障。
	* 解耦：降低維護成本，降低耦合風險。減少依賴，減少相互間的影響。
	* 限流：滑動視窗計數法、漏桶演算法、令牌桶演算法等演算法。遇到突發流量時，保證系統穩定。
	* 降級：緊急情況下釋放非核心功能的資源。犧牲非核心業務，保證核心業務的高可用。
	* 熔斷：異常情況超出閾值進入熔斷狀態，快速失敗。減少不穩定的外部依賴對核心服務的影響。
	* 自動化測試：通過完善的測試，減少釋出引起的故障。
	* 灰度釋出：灰度釋出是速度與安全性作為妥協，能夠有效減少釋出故障。


* [《關於高可用的系統》](https://coolshell.cn/articles/17459.html)
	* 設計原則：資料不丟(持久化)；服務高可用(服務副本)；絕對的100%高可用很難，目標是做到儘可能多的9，如99.999%（全年累計只有5分鐘）。	 

### 硬體負載均衡

* [《轉！！負載均衡器技術Nginx和F5的優缺點對比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)
	* 主要是和F5對比。

* [《軟/硬體負載均衡產品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)

### 軟體負載均衡

* [《幾種負載均衡演算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)
	輪尋、權重、負載、最少連線、QoS
* [《DNS負載均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)
	* 配置簡單，更新速度慢。
* [《Nginx負載均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)
	* 簡單輕量、學習成本低；主要適用於web應用。

*  [《藉助LVS+Keepalived實現負載均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)
	* 配置比較負載、只支援到4層，效能較高。

* [《HAProxy用法詳解 全網最詳細中文文件》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)
	* 支援到七層（比如HTTP）、功能比較全面，效能也不錯。

* [《Haproxy+Keepalived+MySQL實現讀均衡負載》](http://blog.itpub.net/25704976/viewspace-1319781/)
	* 主要是使用者讀請求的負載均衡。

* [《rabbitmq+haproxy+keepalived實現高可用叢集搭建》](https://www.cnblogs.com/lylife/p/5584019.html)

### 限流

* [《談談高併發系統的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)
	* 計數器：通過滑動視窗計數器，控制單位時間內的請求次數，簡單粗暴。
	* 漏桶演算法：固定容量的漏桶，漏桶滿了就丟棄請求，比較常用。
	* 令牌桶演算法：固定容量的令牌桶，按照一定速率新增令牌，處理請求前需要拿到令牌，拿不到令牌則丟棄請求，或進入丟佇列，可以通過控制新增令牌的速率，來控制整體速度。Guava 中的 RateLimiter 是令牌桶的實現。
	* Nginx 限流：通過 `limit_req` 等模組限制併發連線數。

### 應用層容災

* [《防雪崩利器：熔斷器 Hystrix 的原理與使用》](https://segmentfault.com/a/1190000005988895)
	* 雪崩效應原因：硬體故障、硬體故障、程式Bug、重試加大流量、使用者大量請求。
	* 雪崩的對策：限流、改進快取模式(快取預載入、同步呼叫改非同步)、自動擴容、降級。
	* Hystrix設計原則：
		* 資源隔離：Hystrix通過將每個依賴服務分配獨立的執行緒池進行資源隔離, 從而避免服務雪崩。
		* 熔斷開關：服務的健康狀況 = 請求失敗數 / 請求總數，通過閾值設定和滑動視窗控制開關。
		* 命令模式：通過繼承 HystrixCommand 來包裝服務呼叫邏輯。

* [《快取穿透，快取擊穿，快取雪崩解決方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)
* [《快取擊穿、失效以及熱點key問題》](https://blog.csdn.net/zeb_perfect/article/details/54135506)
	* 主要策略：失效瞬間：單機使用鎖；使用分散式鎖；不過期；
	* 熱點資料：熱點資料單獨儲存；使用本地快取；分成多個子key；

### 跨機房容災

* [《“異地多活”多機房部署經驗談》](http://dc.idcquan.com/ywgl/71559.shtml)
	* 通過自研中介軟體進行資料同步。

* [《異地多活（異地雙活）實踐經驗》](https://blog.csdn.net/jeffreynicole/article/details/48135093)
	* 注意延遲問題，多次跨機房呼叫會將延時放大數倍。
	* 建房間專線很大概率會出現問題，做好運維和程式層面的容錯。
	* 不能依賴於程式端資料雙寫，要有自動同步方案。
	* 資料永不在高延遲和較差網路質量下，考慮同步質量問題。
	* 核心業務和次要業務分而治之，甚至只考慮核心業務。
	* 異地多活監控部署、測試也要跟上。
	* 業務允許的情況下考慮使用者分割槽，尤其是遊戲、郵箱業務。
	* 控制跨機房訊息體大小，越小越好。
	* 考慮使用docker容器虛擬化技術，提高動態排程能力。

* [容災技術及建設經驗介紹](https://blog.csdn.net/yoara/article/details/38013751)


### 容災演練流程

* [《依賴治理、灰度釋出、故障演練，阿里電商故障演練系統的設計與實戰經驗》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)
	* 常見故障畫像
	* 案例：預案有效性、預案有效性、故障復現、架構容災測試、引數調優、引數調優、故障突襲、聯合演練。

### 平滑啟動

* 平滑重啟應用思路
1.端流量（如vip層）、2. flush 資料(如果有)、3, 重啟應用

* [《JVM安全退出（如何優雅的關閉java服務）》](https://blog.csdn.net/u011001084/article/details/73480432)
推薦推出方式：System.exit，Kill SIGTERM；不推薦 kill-9；用 Runtime.addShutdownHook 註冊鉤子。
* [《常見Java應用如何優雅關閉》](http://ju.outofmemory.cn/entry/337235)
Java、Srping、Dubbo 優雅關閉方式。

## 資料庫擴充套件

### 讀寫分離模式

* [《Mysql主從方案的實現》](https://www.cnblogs.com/houdj/p/6563771.html)
* [《搭建MySQL主從複製經典架構》](https://www.cnblogs.com/edisonchou/p/4133148.html)
* [《Haproxy+多臺MySQL從伺服器(Slave) 實現負載均衡》](https://blog.csdn.net/nimasike/article/details/48048341)

* [《DRBD+Heartbeat+Mysql高可用讀寫分離架構》](https://www.cnblogs.com/zhangsubai/p/6801764.html)
	* DRDB 進行磁碟複製，避免單點問題。

* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)

### 分片模式
* [《分庫分表需要考慮的問題及方案》](https://www.jianshu.com/p/32b3e91aa22c)
	* 中介軟體： 輕量級：sharding-jdbc、TSharding；重量級：Atlas、MyCAT、Vitess等。
	* 問題：事務、Join、遷移、擴容、ID、分頁等。
	* 事務補償：對資料進行對帳檢查;基於日誌進行比對;定期同標準資料來源進行同步等。
	* 分庫策略：數值範圍；取模；日期等。
	* 分庫數量：通常 MySQL 單庫 5千萬條、Oracle 單庫一億條需要分庫。

* [《MySql分表和表分割槽詳解》](https://www.2cto.com/database/201503/380348.html)
	* 分割槽：是MySQL內部機制，對客戶端透明，資料儲存在不同檔案中，表面上看是同一個表。
	* 分表：物理上建立不同的表、客戶端需要管理分表路由。

## 服務治理
###  服務註冊與發現

* [《永不失聯！如何實現微服務架構中的服務發現？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)
  * 客戶端服務發現模式：客戶端直接查詢登錄檔，同時自己負責負載均衡。Eureka 採用這種方式。
  * 伺服器端服務發現模式：客戶端通過負載均衡查詢服務例項。
* [《SpringCloud服務註冊中心比較:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)
  * CAP支援：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）
  * 作者認為目前 Consul 對 Spring cloud 的支援比較好。

* [《基於Zookeeper的服務註冊與發現》](http://mobile.51cto.com/news-502394.htm)
	* 優點：API簡單、Pinterest，Airbnb 在用、多語言、通過watcher機制來實現配置PUSH，能快速響應配置變化。

### 服務路由控制
* [《分散式服務框架學習筆記4 服務路由》](https://blog.csdn.net/xundh/article/details/59492750)
	* 原則：透明化路由
	* 負載均衡策略：隨機、輪詢、服務呼叫延遲、一致性雜湊、粘滯連線
	* 本地路由有限策略：injvm(優先呼叫jvm內部的服務)，innative(優先使用相同物理機的服務),原則上找距離最近的服務。
	* 配置方式：統一登錄檔；本地配置；動態下發。

## 分散式一致

### CAP 與 BASE 理論

* [《從分散式一致性談到CAP理論、BASE理論》](http://www.cnblogs.com/szlbm/p/5588543.html)
	* 一致性分類：強一致(立即一致)；弱一致(可在單位時間內實現一致，比如秒級)；最終一致(弱一致的一種，一定時間內最終一致)
	* CAP：一致性、可用性、分割槽容錯性(網路故障引起)
	* BASE：Basically Available（基本可用）、Soft state（軟狀態）和Eventually consistent（最終一致性）
	* BASE理論的核心思想是：即使無法做到強一致性，但每個應用都可以根據自身業務特點，採用適當的方式來使系統達到最終一致性。

### 分散式鎖

* [《分散式鎖的幾種實現方式》](http://www.hollischuang.com/archives/1716)
	* 基於資料庫的分散式鎖：優點：操作簡單、容易理解。缺點：存在單點問題、資料庫效能夠開銷較大、不可重入；
	* 基於快取的分散式鎖：優點：非阻塞、效能好。缺點：操作不好容易造成鎖無法釋放的情況。
	* Zookeeper 分散式鎖：通過有序臨時節點實現鎖機制，自己對應的節點需要最小，則被認為是獲得了鎖。優點：叢集可以透明解決單點問題，避免鎖不被釋放問題，同時鎖可以重入。缺點：效能不如快取方式，吞吐量會隨著zk叢集規模變大而下降。
* [《基於Zookeeper的分散式鎖》](https://www.tuicool.com/articles/VZJr6fY)
	* 清楚的原理描述 + Java 程式碼示例。

* [《jedisLock—redis分散式鎖實現》](https://www.cnblogs.com/0201zcr/p/5942748.html)
	* 基於 setnx(set if ont exists)，有則返回false，否則返回true。並支援過期時間。

* [《Memcached 和 Redis 分散式鎖方案》](https://blog.csdn.net/albertfly/article/details/77412333)
	* 利用 memcached 的 add（有別於set）操作，當key存在時，返回false。

### 分散式一致性演算法

#### PAXOS
* [《分散式系列文章——Paxos演算法原理與推導》](https://www.cnblogs.com/linbingdong/p/6253479.html)
* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)
* [《【分散式】Zookeeper與Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)

#### Zab
* [《Zab：Zookeeper 中的分散式一致性協議介紹》](https://www.jianshu.com/p/fb527a64deee)

#### Raft
* [《Raft 為什麼是更易理解的分散式一致性演算法》](http://www.cnblogs.com/mindwind/p/5231986.html)
	* 三種角色：Leader（領袖）、Follower（群眾）、Candidate（候選人）
	* 通過隨機等待的方式發出投票，得票多的獲勝。

#### Gossip
* [《Gossip演算法》](http://blog.51cto.com/tianya23/530743)

#### 兩階段提交、多階段提交

* [《關於分散式事務、兩階段提交協議、三階提交協議》](http://blog.jobbole.com/95632/)

### 冪等

* [《分散式系統---冪等性設計》](https://www.cnblogs.com/wxgblogs/p/6639272.html)
	* 冪等特性的作用：該資源具備冪等性，請求方無需擔心重複呼叫會產生錯誤。
	* 常見保證冪等的手段：MVCC（類似於樂觀鎖）、去重表(唯一索引)、悲觀鎖、一次性token、序列號方式。

### 分散式一致方案
* [《分散式系統事務一致性解決方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)
* [《保證分散式系統資料一致性的6種方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)

### 分散式 Leader 節點選舉
* [《利用zookeeper實現分散式leader節點選舉》](https://blog.csdn.net/johnson_moon/article/details/78809995)

### TCC(Try/Confirm/Cancel) 柔性事務
* [《傳統事務與柔性事務》](https://www.jianshu.com/p/ab1a1c6b08a1)
	* 基於BASE理論：基本可用、柔性狀態、最終一致。
	* 解決方案：記錄日誌+補償（正向補充或者回滾）、訊息重試(要求程式要冪等)；“無鎖設計”、採用樂觀鎖機制。

## 分散式檔案系統

* [說說分散式檔案儲存系統-基本架構](https://zhuanlan.zhihu.com/p/27666295) ？
* [《各種分散式檔案系統的比較》](https://blog.csdn.net/gatieme/article/details/44982961) ？
  * HDFS：大批量資料讀寫，用於高吞吐量的場景，不適合小檔案。
  * FastDFS：輕量級、適合小檔案。

## 唯一ID 生成

### 全域性唯一ID
* [《高併發分散式系統中生成全域性唯一Id彙總》](https://www.cnblogs.com/baiwa/p/5318432.html)
	* Twitter 方案（Snowflake 演算法）：41位時間戳+10位機器標識（比如IP，伺服器名稱等）+12位序列號(本地計數器)
	* Flicker 方案：MySQL自增ID + "REPLACE INTO XXX:SELECT LAST_INSERT_ID();"
	* UUID：缺點，無序，字串過長，佔用空間，影響檢索效能。
	* MongoDB 方案：利用 ObjectId。缺點：不能自增。

* [《TDDL 在分散式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)
	* 在資料庫中建立 sequence 表，用於記錄，當前已被佔用的id最大值。
	* 每臺客戶端主機取一個id區間（比如 1000~2000）快取在本地，並更新 sequence 表中的id最大值記錄。
	* 客戶端主機之間取不同的id區間，用完再取，使用樂觀鎖機制控制併發。

## 一致性Hash演算法

* [《一致性雜湊演算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)

# 設計思想 & 開發模式

## DDD(Domain-driven Design - 領域驅動設計)

* [《淺談我對DDD領域驅動設計的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)
  * 概念：DDD 主要對傳統軟體開發流程(分析-設計-編碼)中各階段的割裂問題而提出，避免由於一開始分析不明或在軟體開發過程中的資訊流轉不一致而造成軟體無法交付（和需求方設想不一致）的問題。DDD 強調一切以領域（Domain）為中心，強調領域專家（Domain Expert）的作用，強調先定義好領域模型之後在進行開發，並且領域模型可以指導開發（所謂的驅動）。
  * 過程：理解領域、拆分領域、細化領域，模型的準確性取決於模型的理解深度。
  * 設計：DDD 中提出了建模工具，比如聚合、實體、值物件、工廠、倉儲、領域服務、領域事件來幫助領域建模。

* [《領域驅動設計的基礎知識總結》](https://www.cnblogs.com/butterfly100/p/7827870.html)
  * 領域（Doamin）本質上就是問題域，比如一個電商系統，一個論壇系統等。
  * 界限上下文（Bounded Context）：闡述子域之間的關係，可以簡單理解成一個子系統或元件模組。
  * 領域模型（Domain Model）：DDD的核心是建立（用通用描述語言、工具—領域通用語言）正確的領域模型；反應業務需求的本質，包括實體和過程；其貫穿軟體分析、設計、開發 的整個過程；常用表達領域模型的方式：圖、程式碼或文字；
  * 領域通用語言：領域專家、開發設計人員都能立即的語言或工具。
  * 經典分層架構：使用者介面/展示層、應用層、領域層、基礎設施層，是四層架構模式。
  * 使用的模式：
    * 關聯儘量少，儘量單項，儘量降低整體複雜度。
    * 實體（Entity）：領域中的唯一標示，一個實體的屬性儘量少，少則清晰。
    * 值物件（Value Object）：沒有唯一標識，且屬性值不可變，小二簡單的物件，比如Date。
    * 領域服務（Domain Service）： 協調多個領域物件，只有方法沒有狀態(不存資料)；可以分為應用層服務，領域層服務、基礎層服務。
    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定義了一組具有內聚關係的相關物件的集合；聚合根是對聚合引用的唯一元素；當修改一個聚合時，必須在事務級別；大部分領域模型中，有70%的聚合通常只有一個實體，30%只有2~3個實體；如果一個聚合只有一個實體，那麼這個實體就是聚合根；如果有多個實體，那麼我們可以思考聚合內哪個物件有獨立存在的意義並且可以和外部直接進行互動；
    * 工廠（Factory）：類似於設計模式中的工廠模式。
    * 倉儲（Repository）：持久化到DB，管理物件，且只對聚合設計倉儲。

* [《領域驅動設計(DDD)實現之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)
	* 聚合：比如一輛汽車（Car）包含了引擎（Engine）、車輪（Wheel）和油箱（Tank）等元件，缺一不可。

* [《領域驅動設計系列（2）淺析VO、DTO、DO、PO的概念、區別和用處》](http://www.hollischuang.com/archives/553)


### 命令查詢職責分離(CQRS)

CQRS — Command Query Responsibility Seperation

* [《領域驅動設計系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)
	* 核心思想：讀寫分離（查詢和更新在不同的方法中），不同的流程只是不同的設計方式，CQ程式碼分離，分散式環境中會有明顯體現（有冗餘資料的情況下），目的是為了高效能。

* [《DDD CQRS架構和傳統架構的優缺點比較》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)
	* 最終一致的設計理念；依賴於高可用訊息中介軟體。

* [《CQRS架構簡介》](http://www.cnblogs.com/netfocus/p/4055346.html)
	* 一個實現 CQRS 的抽象案例。

* [《深度長文：我對CQRS/EventSourcing架構的思考》](http://www.uml.org.cn/zjjs/201609221.asp)
	* CQRS 模式分析 + 12306 搶票案例

### 貧血，充血模型

* [《貧血，充血模型的解釋以及一些經驗》](https://kb.cnblogs.com/page/520743/)
	* 失血模型：老子和兒子分別定義，相互不知道，二者實體定義中完全沒有業務邏輯，通過外部Service進行關聯。
	* 貧血模型：老子知道兒子，兒子也知道老子；部分業務邏輯放到實體中；優點：各層單項依賴，結構清楚，易於維護；缺點：不符合OO思想，相比於充血模式，Service層較為厚重；
	* 充血模型：和貧血模型類似，區別在於如何劃分業務邏輯。優點：Service層比較薄，只充當Facade的角色，不和DAO打交道、複合OO思想；缺點：非單項依賴，DO和DAO之間雙向依賴、和Service層的邏輯劃分容易造成混亂。
	* 腫脹模式：是一種極端情況，取消Service層、全部業務邏輯放在DO中；優點：符合OO思想、簡化了分層；缺點：暴露資訊過多、很多非DO邏輯也會強行併入DO。這種模式應該避免。
	* 作者主張使用貧血模式。

## Actor 模式

TODO

## 響應式程式設計

### Reactor
TODO
### RxJava
TODO
### Vert.x
TODO

## DODAF2.0

* [《DODAF2.0方法論》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)
* [《DODAF2.0之能力視角如何落地》](http://blog.51cto.com/xiaoyong/1553164)

## Serverless

TODO

# 專案管理

## 架構評審
* [《架構設計之如何評審架構設計說明書》](http://developer.51cto.com/art/201506/478486.htm)
* [《人人都是架構師：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)

## 重構

* [《架構之重構的12條軍規》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)

## 程式碼規範

TODO

## 程式碼 Review


制度還是制度!
另外，每個公司需要根據自己的需求和目標制定自己的 check list

* [《為什麼你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)
	* 程式碼 review 做的好，在於制度建設。

* [《從零開始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)

* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)
* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)

* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)

## RUP
* [《運用RUP 4+1檢視方法進行軟體架構設計》](https://blog.csdn.net/apanious/article/details/51011946)

## 看板管理
* [《說說看板在專案中的應用》](https://blog.csdn.net/tkchen/article/details/51637643)

## SCRUM

* [《敏捷專案管理流程-Scrum框架最全總結！》](https://blog.csdn.net/inny100_100/article/details/54633757)

## 極限程式設計

TODO

## 敏捷開發

TODO

## 結對程式設計

TODO

## FMEA管理模式

TODO

# 通用業務術語

TODO

# 技術趨勢

TODO

# 政策、法規

TODO

## 嚴格遵守刑法253法條

我國刑法第253條之一規定：

> * 國家機關或者金融、電信、交通、教育、醫療等單位的工作人員，違反國家規定，將本單位在履行職責或者提供服務過程中獲得的公民個人資訊，出售或者非法提供給他人，情節嚴重的，處3年以下有期徒刑或者拘役，並處或者單處罰金。
> * 竊取或者以其他方法非法獲取上述資訊，情節嚴重的，依照前款的規定處罰。
> * 單位犯前兩款罪的，對單位判處罰金，並對其直接負責的主管人員和其他直接責任人員，依照各該款的規定處罰。

最高人民法院、最高人民檢察院關於執行《中華人民共和國刑法》確定罪名的補充規定（四）規定：觸犯刑法第253條之一第1款之規定，構成“出售、非法提供公民個人資訊罪”；觸犯刑法第253條之一第2款之規定，構成“非法獲取公民個人資訊罪”




# 架構師素質

* [《架構師畫像》](http://hellojava.info/?p=430)
	* 業務理解和抽象能力
	* NB的程式碼能力
	* 全面：1. 在面對業務問題上，架構師腦海裡是否會浮現出多種技術方案；2. 在做系統設計時是否考慮到了足夠多的方方面面；3. 在做系統設計時是否考慮到了足夠多的方方面面；
	* 全域性：是否考慮到了對上下游的系統的影響。
	* 權衡：權衡投入產出比；優先順序和節奏控制；

* [《關於架構優化和設計，架構師必須知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)
	* 要去考慮的細節：模組化、輕耦合、無共享架構；減少各個元件之前的依懶、注意服務之間依懶所有造成的鏈式失敗及影響等。
	* 基礎設施、配置、測試、開發、運維綜合考慮。
	* 考慮人、團隊、和組織的影響。

* [《如何才能真正的提高自己，成為一名出色的架構師？》](https://www.zhihu.com/question/19841397)

* [《架構師的必備素質和成長途徑》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)
	* 素質：業務理解、技術廣度、技術深度、豐富經驗、溝通能力、動手能力、美學素養。
	* 成長路徑：2年積累知識、4年積累技能和祖內影響力、7年積累部門內影響力、7年以上積累跨部門影響力。

* [《架構設計師—你在哪層樓？》](http://blog.51cto.com/frankfan/1248401)
	* 第一層的架構師看到的只是產品本身
	* 第二層的架構師不僅看到自己的產品，還看到了整體的方案
	* 第三層的架構師看到的是商業價值

# 團隊管理

TODO

## 招聘

# 資訊

## 行業資訊

* [36kr](http://36kr.com/)
* [Techweb](http://www.techweb.com.cn/)

## 公眾號列表

TODO

## 部落格

### 團隊部落格
* [阿里中介軟體部落格](http://jm.taobao.org/)
* [美團點評技術團隊部落格](https://tech.meituan.com)

### 個人部落格

* [阮一峰的網路日誌](http://www.ruanyifeng.com/)
* [酷殼 - COOLSHELL-陳皓](https://coolshell.cn/)
* [hellojava-阿里畢玄](http://hellojava.info/)
* [Cm's Blog](http://cmsblogs.com/)

## 綜合門戶、社羣

**國內：**

* [CSDN](http://csdn.net)
	 老牌技術社羣、不必解釋。
* [51cto.com](http://www.51cto.com/)
* [ITeye](http://www.iteye.com/)
	* 偏 Java 方向
* [部落格園](https://www.cnblogs.com)
* [ChinaUnix](http://www.tom.net/)
	* 偏 Linux 方向
* [開源中國社羣](https://www.oschina.net/)
* [深度開源](http://www.open-open.com/)
* [伯樂線上](http://www.jobbole.com/)
	* 涵蓋 IT職場、Web前端、後端、移動端、資料庫等方面內容，偏技術端。

* [ITPUB](http://www.itpub.net/)
* [騰訊雲— 雲+社羣](https://cloud.tencent.com/developer/column)
* [阿里雲— 雲棲社羣](https://yq.aliyun.com/)
* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)
* [開發者頭條](https://toutiao.io/)
* [LinkedKeeper](http://www.linkedkeeper.com)

**國外：**

* [DZone](https://dzone.com)
* [Reddit](https://www.reddit.com)

## 問答、討論類社羣

* [segmentfault](https://segmentfault.com)
	* 問答+專欄
* [知乎](https://www.zhihu.com/)
* [stackoverflow](https://stackoverflow.com/)

## 行業資料分析

* [艾瑞網](http://report.iresearch.cn/)
* [QUEST MOBILE](https://www.questmobile.com.cn)

## 專項網站

* 測試:
	* [領測國際](http://www.ltesting.net/)
	* [測試窩](https://www.testwo.com/)
	* [TesterHome](https://testerhome.com)

* 運維:
  	* [運維派](http://www.yunweipai.com/)
  	* [Abcdocker](https://www.abcdocker.com/)

* Java:
	* [ImportNew](http://www.importnew.com/)
		* 專注於 Java 技術分享
	* [HowToDoInJava](https://howtodoinjava.com/)
		* 英文部落格

* 安全
	* [紅黑聯盟](https://www.2cto.com/)
	* [FreeBuf](http://www.freebuf.com/)

* 大資料
	* [中國大資料](http://www.thebigdata.cn/)

* 其他專題網站：
	* [DockerInfo](http://www.dockerinfo.net/)
		* 專注於 Docker 應用及諮詢、教程的網站。
	* [Linux公社](https://www.linuxidc.com/)
		* Linux 主題社羣

## 其他類

* [程式設計師技能圖譜](https://github.com/TeamStuQ/skill-map)

## 推薦參考書


### 線上電子書

* [《深入理解Spring Cloud與微服務構建》](https://github.com/forezp/SpringCloudLearning)


* [《阿里技術參考圖冊-研發篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)
* [《阿里技術參考圖冊-演算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)

* [《2018美團點評技術年貨（合輯）》70M](http://dpurl.cn/n/1lqcX)

* [InfoQ《架構師》月刊](http://www.infoq.com/cn/architect/)

### 紙質書

#### 開發方面

* 《阿里巴巴Java開發手冊》[京東](https://union-click.jd.com/jdc?d=bVKwZQ) [淘寶](https://s.taobao.com/search?q=阿里巴巴Java開發手冊)

#### 架構方面
* 《軟體架構師的12項修煉：技術技能篇》[京東](https://union-click.jd.com/jdc?d=gXvRd8) [淘寶](https://s.taobao.com/search?q=軟體架構師的12項修煉：技術技能篇)
* 《架構之美》[京東](https://union-click.jd.com/jdc?d=xJit5I) [淘寶](https://s.taobao.com/search?q=架構之美)
* 《分散式服務架構》[京東](https://union-click.jd.com/jdc?d=JS5Od9) [淘寶](https://s.taobao.com/search?q=分散式服務架構)
* 《聊聊架構》 [京東](https://union-click.jd.com/jdc?d=FHooH4) [淘寶](https://s.taobao.com/search?q=聊聊架構)
* 《雲原生應用架構實踐》[京東](https://union-click.jd.com/jdc?d=orkJSj) [淘寶](https://s.taobao.com/search?q=雲原生應用架構實踐)
* 《億級流量網站架構核心技術》[京東](https://union-click.jd.com/jdc?d=RnOSP5) [淘寶](https://s.taobao.com/search?q=億級流量網站架構核心技術)
* 《淘寶技術這十年》[京東](https://union-click.jd.com/jdc?d=LwrDfD) [淘寶](https://s.taobao.com/search?q=淘寶技術這十年)
* 《企業IT架構轉型之道-中臺戰略思想與架構實戰》 [京東](https://union-click.jd.com/jdc?d=89pAEm) [淘寶](https://s.taobao.com/search?q=企業IT架構轉型之道)

#### 技術管理方面
* 《CTO說》[京東](https://union-click.jd.com/jdc?d=zhTZyr) [淘寶](https://s.taobao.com/search?q=CTO說)
* 《技術管理之巔》[京東](https://union-click.jd.com/jdc?d=LgRBUW) [淘寶](https://s.taobao.com/search?q=技術管理之巔)
* 《網易一千零一夜：網際網路產品專案管理實戰》[京東](https://union-click.jd.com/jdc?d=jcRz2r) [淘寶](https://s.taobao.com/search?q=網易一千零一夜：網際網路產品專案管理實戰)

#### 基礎理論
* 《數學之美》[京東](https://union-click.jd.com/jdc?d=ghIES2) [淘寶](https://s.taobao.com/search?q=數學之美)
* 《程式設計珠璣》[京東](https://union-click.jd.com/jdc?d=YmhdEu) [淘寶](https://s.taobao.com/search?q=程式設計珠璣)

#### 工具方面
TODO

#### 大資料方面

# 技術資源

## 開源資源
* [github](https://github.com)

* [Apache 軟體基金會](https://www.apache.org/index.html)

## 手冊、文件、教程

**國內：**
* [W3Cschool](http://w3cschool.cn)
* [Runoob.com](http://www.runoob.com/)
	* HTML 、 CSS、XML、Java、Python、PHP、設計模式等入門手冊。

* [Love2.io](https://love2.io/)
	* 很多很多中文線上電子書，是一個全新的開源技術文件分享平臺。
* [gitbook.cn](http://gitbook.cn/)
	* 付費電子書。
* [ApacheCN](http://www.apachecn.org/)
	* AI、大資料方面系列中文文件。

**國外：**

* [Quick Code](http://www.quickcode.co/)
	* 免費線上技術教程。
* [gitbook.com](http://gitbook.com)
	* 有部分中文電子書。
* [Cheatography](https://www.cheatography.com/)
	* Cheat Sheets 大全，單頁文件網站。


## 線上課堂

* [學徒無憂](http://www.xuetuwuyou.com/)
* [極客時間](https://time.geekbang.org/)
* [segmentfault](https://segmentfault.com/lives)
* [斯達克學院](https://new.stuq.org/course/explore)
* [牛客網](http://nowcoder.com)
* [極客學院](https://www.jikexueyuan.com/)
* [51CTO學院](http://edu.51cto.com/)

## 會議、活動

* [QCon](http://www.infoq.com/cn/qcon/)
* [ArchSummit](https://archsummit.com)
* [GITC全球網際網路技術大會](http://www.thegitc.com/)

**活動釋出平臺:**
* [活動行](http://www.huodongxing.com/)

## 常用APP

* [極客時間](https://time.geekbang.org)
* [得到](https://www.igetget.com)

## 找工作
* [Boss直聘](https://www.zhipin.com)
* [拉勾網](https://www.lagou.com)
* [獵聘](https://www.liepin.com)
* [100Offer](https://cn.100offer.com/)

## 工具

* [極客搜尋](https://s.geekbang.org/)
	* 技術文章搜尋引擎。

## 程式碼託管

* [Coding](https://coding.net)
* [碼雲](https://gitee.com/)

## 檔案服務
* 七牛
* 又拍雲

## 綜合雲服務商
* 阿里雲
* 騰訊雲
* 百度雲
* 新浪雲
* 金山雲
